#include "init.h"

#include <Aikari-Launcher-Public/constants/itcCtrl/base.h>
#include <Aikari-Launcher-Public/constants/itcCtrl/filesystem.h>
#include <Aikari-Launcher-Public/constants/itcCtrl/network.h>
#include <Aikari-Launcher-Public/constants/lifecycle.h>
#include <Aikari-PLS/types/constants/init.h>
#include <Aikari-PLS/types/constants/msgQueue.h>
#include <Aikari-Shared/infrastructure/loggerMacro.h>
#include <Aikari-Shared/infrastructure/queue/SinglePointMessageQueue.hpp>
#include <Aikari-Shared/types/itc/shared.h>
#include <Aikari-Shared/utils/crypto.h>
#include <Aikari-Shared/utils/filesystem.h>
#include <Aikari-Shared/utils/windows.h>
#include <chrono>
#include <infrastructure/threadMsgHandler.h>
#include <optional>

#include "components/infrastructure/config.h"
#include "components/mqtt/mqttBroker.h"
#include "components/ruleSystem/rulesManager.h"
#include "lifecycle.h"
#include "resource.h"

namespace plsConstants = AikariPLS::Types::Constants;

namespace itcConstants = AikariShared::Types::InterThread;

namespace AikariPLS::Init
{
    constexpr const char* hostLine =
        "127.11.45.14 iot-broker-mis.seewo.com # This line is generated by "
        "HugoAura-Aikari, please do not edit or delete it";

    constexpr const char* swCoreProcName = "SeewoCore.exe";

    namespace HelperFns
    {
        static void _pushSwCoreProcKilledEvent(
            AikariShared::Infrastructure::MessageQueue::SinglePointMessageQueue<
                itcConstants::SubToMainMessageInstance>* msgQueue
        )
        {
            itcConstants::SubToMainWebSocketReply wsMsg = {
                .success = true,
                .code = 0,
                .data = { { "message",
                            plsConstants::Init::NetworkInit::
                                SW_CORE_PROC_KILLED_MSG },
                          { "method",
                            plsConstants::Init::NetworkInit::
                                SW_CORE_PROC_KILLED_PUSH_METHOD } },
                .eventId = plsConstants::MsgQueue::WebSocket::WS_MSG_TYPE_PUSH,
                .wsInfo = { .isBroadcast = true }
            };

            itcConstants::SubToMainMessageInstance msgIns = {
                .type = itcConstants::MESSAGE_TYPES::WS_MESSAGE, .msg = wsMsg
            };

            msgQueue->push(msgIns);
        };

        static std::optional<std::filesystem::path> _getAikariDir(
            AikariPLS::Infrastructure::MsgQueue::PLSThreadMsgQueueHandler*
                msgQueueHandler
        )
        {
            itcConstants::SubToMainControlMessage getDirMsg = {
                .method = AikariLauncherPublic::Constants::InterThread::
                    FileSystem::Base::GET_DIR,
                .data = { { "dirType", "aikariRoot" } },
                .fromModule = plsConstants::MsgQueue::MODULE_NAME,
                .eventId =
                    AikariShared::Utils::CryptoUtils::genRandomHexInsecure(32)
            };

            auto getDirResult = msgQueueHandler->sendCtrlMsgSync(getDirMsg);

            if (!getDirResult.data.value("success", false))
            {
                LOG_ERROR(
                    "Failed to get Aikari DIR: TPC failure"
                    ". Diagnose code: {}",
                    getDirResult.data.value("diagnoseCode", "UNKNOWN")
                );
                return std::nullopt;
            }

            std::filesystem::path aikariDir(
                static_cast<std::string>(getDirResult.data.at("path"))
            );

            return aikariDir;
        };

        static bool _initMqttCert(
            AikariPLS::Infrastructure::MsgQueue::PLSThreadMsgQueueHandler*
                msgQueueHandler,
            const std::filesystem::path& aikariDir
        )
        {
#ifdef _DEBUG
            LOG_TRACE(
                "Init MQTT cert: Input Aikari DIR: {}", aikariDir.string()
            );
#endif

            if (std::filesystem::exists(
                    aikariDir / "config" / "certs" / "mqtt.crt"
                ))
            {
                LOG_INFO(
                    "MQTT TLS cert already generated, skipping regeneration..."
                );
                return true;
            }

            itcConstants::SubToMainControlMessage initCertMsg = {
                .method = AikariLauncherPublic::Constants::InterThread::
                    Network::TLS::GEN_TLS_CERTS,
                .data = { { "baseDir",
                            (aikariDir / "config" / "certs").string() },
                          { "hostname",
                            plsConstants::Init::NetworkInit::HOSTNAME },
                          { "identifier",
                            plsConstants::Init::NetworkInit::
                                TLS_CERT_IDENTIFIER } },
                .fromModule = plsConstants::MsgQueue::MODULE_NAME,
                .eventId =
                    AikariShared::Utils::CryptoUtils::genRandomHexInsecure(32)
            };

            auto initCertResult = msgQueueHandler->sendCtrlMsgSync(initCertMsg);

            if (!initCertResult.data.value("success", false))
            {
                LOG_ERROR(
                    "Failed to init MQTT cert: Error generating cert: {} | "
                    "Diagnose code: {}",
                    initCertResult.data.value("message", "Unknown Error"),
                    initCertResult.data.value("diagnoseCode", "UNKNOWN")
                );
                return false;
            }

            LOG_INFO("Successfully generated MQTT TLS cert.");
            return true;
        };

        static AikariLauncherPublic::Constants::Lifecycle::
            APPLICATION_RUNTIME_MODES
            _getRuntimeMode(
                AikariPLS::Infrastructure::MsgQueue::PLSThreadMsgQueueHandler*
                    msgQueueHandler
            )
        {
            itcConstants::SubToMainControlMessage getRuntimeModeMsg = {
                .method = AikariLauncherPublic::Constants::InterThread::Base::
                    Props::GET_RUNTIME_MODE,
                .data = {},
                .fromModule = plsConstants::MsgQueue::MODULE_NAME,
                .eventId =
                    AikariShared::Utils::CryptoUtils::genRandomHexInsecure(32)
            };

            auto getRuntimeModeResult =
                msgQueueHandler->sendCtrlMsgSync(getRuntimeModeMsg);

            int runtimeModeRaw = getRuntimeModeResult.data.value("mode", 0);

            auto runtimeMode =
                static_cast<AikariLauncherPublic::Constants::Lifecycle::
                                APPLICATION_RUNTIME_MODES>(runtimeModeRaw);

            return runtimeMode;
        };

    }  // namespace HelperFns

    PLSInitSuccess runPlsInit()
    {
        auto& sharedStates =
            AikariPLS::Lifecycle::PLSSharedStates::getInstance();

        auto& sharedIns =
            AikariPLS::Lifecycle::PLSSharedInsManager::getInstance();

        auto* msgQueueHandlerPtr = sharedIns.getPtr(
            &AikariPLS::Types::Lifecycle::PLSSharedIns::threadMsgQueueHandler
        );

        auto& sharedMsgQueues =
            AikariPLS::Lifecycle::PLSSharedQueuesManager::getInstance();

        auto* retMsgQueuePtr = sharedMsgQueues.getPtr(
            &AikariPLS::Types::Lifecycle::PLSSharedMsgQueues::retMsgQueue
        );

        LOG_DEBUG("Pulling Aikari runtime mode...");
        const auto runtimeMode = HelperFns::_getRuntimeMode(msgQueueHandlerPtr);
        LOG_TRACE("Runtime mode: {}", static_cast<int>(runtimeMode));
        sharedStates.setVal(
            &AikariPLS::Types::Lifecycle::PLSSharedStates::runtimeMode,
            runtimeMode
        );

        LOG_DEBUG("Getting Aikari DIR...");
        std::filesystem::path aikariRootDir;
        {
            const auto getDirResult =
                HelperFns::_getAikariDir(msgQueueHandlerPtr);
            if (getDirResult == std::nullopt)
            {
                LOG_CRITICAL("Failed to get Aikari root DIR, exiting PLS...");
                return false;
            }
            else
            {
                aikariRootDir = getDirResult.value();
            }
        }

        HMODULE selfHModule = sharedIns.getVal(
            &AikariPLS::Types::Lifecycle::PLSSharedIns::hModuleIns
        );

        // ↓ Init Config Manager
        {
            auto configManagerIns = std::make_unique<
                AikariPLS::Components::Config::PLSConfigManager>(
                "pls",
                aikariRootDir / "config" / "config-pls.json",
                IDR_PLS_DEFAULT_CONF,
                selfHModule
            );
            sharedIns.setPtr(
                &AikariPLS::Types::Lifecycle::PLSSharedIns::configMgr,
                std::move(configManagerIns)
            );
        }
        auto* configManagerPtr = sharedIns.getPtr(
            &AikariPLS::Types::Lifecycle::PLSSharedIns::configMgr
        );
        bool initConfigResult = configManagerPtr->initConfig();
        if (!initConfigResult)
        {
            LOG_CRITICAL(
                "Failed to initialize config file for module PLS, exiting "
                "PLS..."
            );
            return false;
        }
        // ↑ Init Config Manager

        // ↓ Init Rule Scripts
        LOG_INFO("Loading rules...");
        {
            LOG_DEBUG("Getting self (DLL's) DIR...");
            auto rulePath =
                AikariShared::Utils::FileSystem::getSelfPathFromHandler(
                    selfHModule
                )
                    .parent_path() /
                "resources" / "pls" / "rules";
            nlohmann::json& ruleConfig = configManagerPtr->config->rules;
            auto ruleManagerIns =
                std::make_unique<AikariPLS::Components::Rules::Manager>(
                    rulePath, ruleConfig
                );
            ruleManagerIns->loadRules();
            sharedIns.setPtr(
                &AikariPLS::Types::Lifecycle::PLSSharedIns::ruleMgr,
                std::move(ruleManagerIns)
            );
        }
        // ↑ Init Rule Scripts

        // ↓ Init Hosts
        LOG_INFO("Checking hosts file entry...");
        AikariShared::Utils::Windows::Network::isSeewoCoreNeedToBeKill
            hostCheckResult =
                AikariShared::Utils::Windows::Network::ensureHostKeyExists(
                    hostLine
                );
        if (hostCheckResult)
        {
            LOG_INFO("Hosts file updated, killing SeewoCore process...");
            try
            {
                AikariShared::Utils::Windows::Process::killProcessByName(
                    swCoreProcName
                );

                std::jthread pushKillEvtThread(
                    [retMsgQueuePtr]()
                    {
                        std::this_thread::sleep_for(std::chrono::seconds(2));
                        HelperFns::_pushSwCoreProcKilledEvent(retMsgQueuePtr);
                    }
                );
                pushKillEvtThread.detach();
            }
            catch (const std::exception& err)
            {
                LOG_ERROR("Failed to kill SeewoCore, error: {}", err.what());
            }
        }
        // ↑ Init Hosts

        // ↓ Init MQTT TLS Env
        LOG_INFO("Ensuring MQTT TLS cert...");
        auto result =
            HelperFns::_initMqttCert(msgQueueHandlerPtr, aikariRootDir);
        if (!result)
        {
            LOG_CRITICAL("Failed to init MQTT cert, exiting PLS...");
            return false;
        }
        // ↑ Init MQTT TLS Env

        // ↓ Init MQTT Broker
        LOG_INFO("Starting MQTT Broker server...");
        LOG_DEBUG(aikariRootDir.string());
        {
            AikariPLS::Components::MQTTBroker::BrokerLaunchArg
                brokerLaunchArg = {
                    .certPath = (aikariRootDir / "config" / "certs" /
                                 std::format(
                                     "{}.crt",
                                     plsConstants::Init::NetworkInit::
                                         TLS_CERT_IDENTIFIER
                                 ))
                                    .string(),
                    .keyPath = (aikariRootDir / "config" / "certs" /
                                std::format(
                                    "{}.key",
                                    plsConstants::Init::NetworkInit::
                                        TLS_CERT_IDENTIFIER
                                ))
                                   .string(),
                    .hostname = plsConstants::Init::NetworkInit::HOSTNAME,
                    .port = plsConstants::Init::NetworkInit::PORT
                };
            auto brokerIns =
                std::make_unique<AikariPLS::Components::MQTTBroker::Broker>(
                    brokerLaunchArg
                );
            sharedIns.setPtr(
                &AikariPLS::Types::Lifecycle::PLSSharedIns::mqttBroker,
                std::move(brokerIns)
            );
        }
        // ↑ Init MQTT Broker

        return true;
    }
}  // namespace AikariPLS::Init
