#include "init.h"

#include <Aikari-Launcher-Public/constants/itcCtrl/base.h>
#include <Aikari-Launcher-Public/constants/itcCtrl/filesystem.h>
#include <Aikari-Launcher-Public/constants/itcCtrl/network.h>
#include <Aikari-Launcher-Public/constants/lifecycle.h>
#include <Aikari-PLS/types/constants/init.h>
#include <Aikari-PLS/types/constants/msgQueue.h>
#include <Aikari-Shared/infrastructure/loggerMacro.h>
#include <Aikari-Shared/infrastructure/queue/SinglePointMessageQueue.hpp>
#include <Aikari-Shared/types/itc/shared.h>
#include <Aikari-Shared/utils/crypto.h>
#include <Aikari-Shared/utils/windows.h>
#include <chrono>
#include <infrastructure/threadMsgHandler.h>
#include <optional>

#include "components/mqtt/mqttBroker.h"
#include "lifecycle.h"

namespace plsConstants = AikariPLS::Types::constants;

namespace itcConstants = AikariShared::Types::InterThread;

namespace AikariPLS::Init
{
    constexpr const char* hostLine =
        "127.11.45.14 iot-broker-mis.seewo.com # This line is generated by "
        "HugoAura-Aikari, please do not edit or delete it";

    constexpr const char* swCoreProcName = "SeewoCore.exe";

    namespace HelperFns
    {
        static void _pushSwCoreProcKilledEvent(
            AikariShared::infrastructure::MessageQueue::SinglePointMessageQueue<
                itcConstants::SubToMainMessageInstance>* msgQueue
        )
        {
            itcConstants::SubToMainWebSocketReply wsMsg = {
                .success = true,
                .code = 0,
                .data = { { "message",
                            plsConstants::init::networkInit::
                                SW_CORE_PROC_KILLED_MSG },
                          { "method",
                            plsConstants::init::networkInit::
                                SW_CORE_PROC_KILLED_PUSH_METHOD } },
                .eventId = plsConstants::msgQueue::WebSocket::WS_MSG_TYPE_PUSH,
                .wsInfo = { .isBroadcast = true }
            };

            itcConstants::SubToMainMessageInstance msgIns = {
                .type = itcConstants::MESSAGE_TYPES::WS_MESSAGE, .msg = wsMsg
            };

            msgQueue->push(msgIns);
        };

        static std::variant<std::filesystem::path, bool> _initMqttCert(
            AikariPLS::Infrastructure::MsgQueue::PLSThreadMsgQueueHandler*
                msgQueueHandler
        )
        {
            itcConstants::SubToMainControlMessage getDirMsg = {
                .method = AikariLauncherPublic::Constants::InterThread::
                    FileSystem::Base::GET_DIR,
                .data = { { "dirType", "aikariRoot" } },
                .fromModule = plsConstants::msgQueue::MODULE_NAME,
                .eventId =
                    AikariShared::utils::cryptoUtils::genRandomHexInsecure(32)
            };

            auto getDirResult = msgQueueHandler->sendCtrlMsgSync(getDirMsg);

            if (!getDirResult.data.value("success", false))
            {
                LOG_ERROR(
                    "Failed to init MQTT cert: Failed to get default directory "
                    "info. Diagnose code: {}",
                    getDirResult.data.value("diagnoseCode", "UNKNOWN")
                );
                return false;
            }

            std::filesystem::path aikariDir(
                static_cast<std::string>(getDirResult.data.at("path"))
            );
#ifdef _DEBUG
            LOG_TRACE("Init MQTT cert: Got AikariDir: {}", aikariDir.string());
#endif

            if (std::filesystem::exists(
                    aikariDir / "config" / "certs" / "mqtt.crt"
                ))
            {
                LOG_INFO(
                    "MQTT TLS cert already generated, skipping regeneration..."
                );
                return aikariDir;
            }

            itcConstants::SubToMainControlMessage initCertMsg = {
                .method = AikariLauncherPublic::Constants::InterThread::
                    Network::TLS::GEN_TLS_CERTS,
                .data = { { "baseDir",
                            (aikariDir / "config" / "certs").string() },
                          { "hostname",
                            plsConstants::init::networkInit::HOSTNAME },
                          { "identifier",
                            plsConstants::init::networkInit::
                                TLS_CERT_IDENTIFIER } },
                .fromModule = plsConstants::msgQueue::MODULE_NAME,
                .eventId =
                    AikariShared::utils::cryptoUtils::genRandomHexInsecure(32)
            };

            auto initCertResult = msgQueueHandler->sendCtrlMsgSync(initCertMsg);

            if (!initCertResult.data.value("success", false))
            {
                LOG_ERROR(
                    "Failed to init MQTT cert: Error generating cert: {} | "
                    "Diagnose code: {}",
                    initCertResult.data.value("message", "Unknown Error"),
                    initCertResult.data.value("diagnoseCode", "UNKNONW")
                );
                return false;
            }

            LOG_INFO("Successfully generated MQTT TLS cert.");

            LOG_DEBUG("Return {}", aikariDir.string());
            return aikariDir;
        };

        static AikariLauncherPublic::Constants::Lifecycle::
            APPLICATION_RUNTIME_MODES
            _getRuntimeMode(
                AikariPLS::Infrastructure::MsgQueue::PLSThreadMsgQueueHandler*
                    msgQueueHandler
            )
        {
            itcConstants::SubToMainControlMessage getRuntimeModeMsg = {
                .method = AikariLauncherPublic::Constants::InterThread::Base::
                    Props::GET_RUNTIME_MODE,
                .data = {},
                .fromModule = plsConstants::msgQueue::MODULE_NAME,
                .eventId =
                    AikariShared::utils::cryptoUtils::genRandomHexInsecure(32)
            };

            auto getRuntimeModeResult =
                msgQueueHandler->sendCtrlMsgSync(getRuntimeModeMsg);

            int runtimeModeRaw = getRuntimeModeResult.data.value("mode", 0);

            auto runtimeMode =
                static_cast<AikariLauncherPublic::Constants::Lifecycle::
                                APPLICATION_RUNTIME_MODES>(runtimeModeRaw);

            return runtimeMode;
        };

    }  // namespace HelperFns

    PLSInitSuccess runPlsInit()
    {
        auto& sharedStates =
            AikariPLS::Lifecycle::PLSSharedStates::getInstance();

        auto& sharedIns =
            AikariPLS::Lifecycle::PLSSharedInsManager::getInstance();

        auto* msgQueueHandlerPtr = sharedIns.getPtr(
            &AikariPLS::Types::lifecycle::PLSSharedIns::threadMsgQueueHandler
        );

        auto& sharedMsgQueues =
            AikariPLS::Lifecycle::PLSSharedQueuesManager::getInstance();

        auto* retMsgQueuePtr = sharedMsgQueues.getPtr(
            &AikariPLS::Types::lifecycle::PLSSharedMsgQueues::retMsgQueue
        );

        LOG_DEBUG("Pulling Aikari runtime mode...");
        const auto runtimeMode = HelperFns::_getRuntimeMode(msgQueueHandlerPtr);
        LOG_TRACE("Runtime mode: {}", static_cast<int>(runtimeMode));
        sharedStates.setVal(
            &AikariPLS::Types::lifecycle::PLSSharedStates::runtimeMode,
            runtimeMode
        );

        LOG_INFO("Checking hosts file entry...");
        AikariShared::utils::windows::network::isSeewoCoreNeedToBeKill
            hostCheckResult =
                AikariShared::utils::windows::network::ensureHostKeyExists(
                    hostLine
                );
        if (hostCheckResult)
        {
            LOG_INFO("Hosts file updated, killing SeewoCore process...");
            try
            {
                AikariShared::utils::windows::process::killProcessByName(
                    swCoreProcName
                );

                std::jthread pushKillEvtThread(
                    [retMsgQueuePtr]()
                    {
                        std::this_thread::sleep_for(std::chrono::seconds(2));
                        HelperFns::_pushSwCoreProcKilledEvent(retMsgQueuePtr);
                    }
                );
                pushKillEvtThread.detach();
            }
            catch (const std::exception& err)
            {
                LOG_ERROR("Failed to kill SeewoCore, error: {}", err.what());
            }
        }

        LOG_INFO("Ensuring MQTT TLS cert...");
        std::filesystem::path aikariDir;
        auto result = HelperFns::_initMqttCert(msgQueueHandlerPtr);
        try
        {
            if (!std::get<bool>(result))
            {
                LOG_CRITICAL("Failed to init MQTT cert, exiting PLS...");
                return false;
            }
        }
        catch (...)
        {
            aikariDir = std::get<std::filesystem::path>(result);
        }

        LOG_INFO("Starting MQTT Broker server...");
        LOG_DEBUG(aikariDir.string());
        AikariPLS::Components::MQTTBroker::BrokerLaunchArg brokerLaunchArg = {
            .certPath =
                (aikariDir / "config" / "certs" /
                 std::format(
                     "{}.crt",
                     plsConstants::init::networkInit::TLS_CERT_IDENTIFIER
                 ))
                    .string(),
            .keyPath = (aikariDir / "config" / "certs" /
                        std::format(
                            "{}.key",
                            plsConstants::init::networkInit::TLS_CERT_IDENTIFIER
                        ))
                           .string(),
            .hostname = plsConstants::init::networkInit::HOSTNAME,
            .port = plsConstants::init::networkInit::PORT
        };
        {
            auto brokerIns =
                std::make_unique<AikariPLS::Components::MQTTBroker::Broker>(
                    brokerLaunchArg
                );
            sharedIns.setPtr(
                &AikariPLS::Types::lifecycle::PLSSharedIns::mqttBroker,
                std::move(brokerIns)
            );
        }

        return true;
    }
}  // namespace AikariPLS::Init
